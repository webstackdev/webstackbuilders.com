/**
 * Prints a mobile first media query based on the name given
 *
 * @param {String} $name - Breakpoint name
 * @require $breakpoints - List of breakpoints and pixel values keyed by name, e.g. `md`
 * @return {String} media query for the breakpoint name provided, using passed attributes
 */
@mixin mq($name) {
  @if map-has-key($breakpoints, $name) {
    @media (min-width: map-get($breakpoints, $name)) {
      @content;
    }
  } @else {
    @error "Breakpoint name `#{$name}` not set in SCSS variables."
        + "Available breakpoints are: #{map-keys($breakpoints)}.";
  }
}

/**
 * Prints a desktop first media query based on the name given
 *
 * @param {String} $name - Breakpoint name
 * @require $breakpoints - List of breakpoints and pixel values keyed by name, e.g. `md`
 * @return {String} media query for the breakpoint name provided, using passed attributes
 */
@mixin mq-down($name) {
  @if map-has-key($breakpoints, $name) {
    @media (max-width: (map-get($breakpoints, $name) - 1px)) {
      @content;
    }
  } @else {
    @error "Breakpoint name `#{$name}` not set in SCSS variables."
        + "Available breakpoints are: #{map-keys($breakpoints)}.";
  }
}

/**
 * Apply a style to :hover and :focus pseudo-classes for a selector.
 */
@mixin hover-focus {
  &:hover,
  &:focus {
    @content;
  }
}

/**
 * Hide information intended only for screen readers from the rendered page. Useful
 * for forms that don't include a label for every input, which will cause problems
 * for screen readers. This is a Bootstrap class originally.
 */
@mixin sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

/**
 * Causes the sr-only element to become visible whenever the element gets focus, and
 * hides it again when the element loses focus. This only occurs when the sr-only
 * element gets focus via the keyboard. This is a Bootstrap class originally.
 */
@mixin sr-only-focusable {
  &:active,
  &:focus {
    position: static;
    width: auto;
    height: auto;
    overflow: visible;
    clip: auto;
    white-space: normal;
  }
}

@mixin body-text() {
  font-size: 1.125rem;
  line-height: 1.65;
  @include mq(md) {
    font-size: 1.375rem;
  }
}

@mixin hyphenate() {
  word-wrap: break-word;
  overflow-wrap: break-word;
  hyphens: auto;
}

@mixin coverall() {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
}

@mixin button-reset() {
  border: 0;
  padding: 0;
  background-color: transparent;
}

@mixin container-narrow() {
  width: 100%;
  max-width: $container-narrow-max-width;
  max-width: var(--content-max-width, #{$container-narrow-max-width});
  margin-left: auto;
  margin-right: auto;
}

@mixin stretched-link() {
  &::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 1;
  }
}

@mixin invert-on-dark() {
  html[data-theme='dark'] &,
  html[data-theme='turnpike'] &,
  html[data-theme='bowser'] &,
  html[data-theme='rainbow'] & {
    filter: invert(1);
  }
}
